#pragma once

#include "../gamemode.qh"

int autocvar_g_ca_point_limit;
int autocvar_g_ca_point_leadlimit;
float autocvar_g_ca_round_timelimit;
bool autocvar_g_ca_team_spawns;
//int autocvar_g_ca_teams;
int autocvar_g_ca_teams_override;
float autocvar_g_ca_warmup;


int ca_teams;
bool allowed_to_spawn;

const int ST_CA_ROUNDS = 1;

bool CA_CheckTeams();
bool CA_CheckWinner();
void CA_RoundStart();
bool ca_isEliminated(entity e);

void SetLimits(int fraglimit_override, int leadlimit_override, float timelimit_override, float qualifying_override);

REGISTER_MUTATOR(ca, false)
{
	MUTATOR_ONADD
	{
		// game loads at time 1
		if (time > 1) error("This is a game type and it cannot be added at runtime.");

		allowed_to_spawn = true;

		ca_teams = autocvar_g_ca_teams_override;
		if (ca_teams < 2)
			ca_teams = cvar("g_ca_teams"); // read the cvar directly as it gets written earlier in the same frame
		ca_teams = bound(2, ca_teams, 4);

		int teams = 0;
		if(ca_teams >= 1) teams |= BIT(0);
		if(ca_teams >= 2) teams |= BIT(1);
		if(ca_teams >= 3) teams |= BIT(2);
		if(ca_teams >= 4) teams |= BIT(3);

		ca_teams = teams; // now set it?

        ScoreRules_basics(teams, SFL_SORT_PRIO_PRIMARY, 0, true);
        ScoreInfo_SetLabel_TeamScore(ST_CA_ROUNDS, "rounds", SFL_SORT_PRIO_PRIMARY);
        ScoreRules_basics_end();

		round_handler_Spawn(CA_CheckTeams, CA_CheckWinner, CA_RoundStart);
		round_handler_Init(5, autocvar_g_ca_warmup, autocvar_g_ca_round_timelimit);

		EliminatedPlayers_Init(ca_isEliminated);

		ActivateTeamplay();
		SetLimits(autocvar_g_ca_point_limit, autocvar_g_ca_point_leadlimit, autocvar_timelimit_override, -1);

		if (autocvar_g_ca_team_spawns)
			have_team_spawns = -1; // request team spawns
	}

	MUTATOR_ONREMOVE
	{
		LOG_INFO("This is a game type and it cannot be removed at runtime.");
		return -1;
	}

	return 0;
}

// should be removed in the future, as other code should not have to care
.float caplayer; // 0.5 if scheduled to join the next round
