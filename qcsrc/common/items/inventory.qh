#ifndef INVENTORY_H
#define INVENTORY_H

#include "all.qh"
#include "item/pickup.qh"

CLASS(Inventory, Object)
    /** Stores counts of items, the id being the index */
    ATTRIBARRAY(Inventory, inv_items, int, Items_MAX)
    /** Previous state */
    ATTRIB(Inventory, inventory, Inventory, NULL)
ENDCLASS(Inventory)

/** Player inventory */
.Inventory inventory;

REGISTER_NET_LINKED(ENT_CLIENT_INVENTORY)

#ifdef CSQC
Inventory g_inventory;
NET_HANDLE(ENT_CLIENT_INVENTORY, bool isnew)
{
    make_pure(this);
    g_inventory = this;
    const int bits = ReadInt24_t();
    FOREACH(Items, bits & BIT(it.m_id), {
        .int fld = inv_items[it.m_id];
        int prev = this.(fld);
        int next = this.(fld) = ReadByte();
        LOG_TRACEF("%s: %.0f -> %.0f\n", it.m_name, prev, next);
    });
    return true;
}
#endif

#ifdef SVQC
void Inventory_Write(Inventory data)
{
    if (!data) {
        WriteInt24_t(MSG_ENTITY, 0);
        return;
    }
    TC(Inventory, data);
    int bits = 0;
    FOREACH(Items, true, {
        .int fld = inv_items[it.m_id];
        bits = BITSET(bits, BIT(it.m_id), data.inventory.(fld) != (data.inventory.(fld) = data.(fld)));
    });
    WriteInt24_t(MSG_ENTITY, bits);
    FOREACH(Items, bits & BIT(it.m_id), {
        WriteByte(MSG_ENTITY, data.inv_items[it.m_id]);
    });
}
#endif

#ifdef SVQC
bool Inventory_Send(Inventory this, Client to, int sf)
{
    TC(Inventory, this);
    WriteHeader(MSG_ENTITY, ENT_CLIENT_INVENTORY);
    entity e = this.owner;
    if (IS_SPEC(e)) e = e.enemy;
    TC(Player, e);
    Inventory data = e.inventory;
    Inventory_Write(data);
    return true;
}

void Inventory_new(entity e)
{
    Inventory inv = NEW(Inventory), bak = NEW(Inventory);
    inv.inventory = bak;
    inv.drawonlytoclient = e;
    Net_LinkEntity((inv.owner = e).inventory = inv, false, 0, Inventory_Send);
}
void Inventory_delete(entity e) { remove(e.inventory.inventory); remove(e.inventory); }
void Inventory_update(entity e) { e.inventory.SendFlags = 0xFFFFFF; }
#endif

#endif
